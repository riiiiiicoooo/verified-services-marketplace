"""
Review System - Reference Implementation
Weighted composite rating engine with double-blind reviews, tier evaluation,
and anti-gaming protections.
"""

from dataclasses import dataclass
from datetime import datetime, timedelta
from typing import Optional


@dataclass
class Review:
    id: str
    request_id: str
    customer_id: str
    provider_id: str
    quality_score: int          # 1-5
    timeliness_score: int       # 1-5
    communication_score: int    # 1-5
    composite_score: float      # Weighted composite
    comment: Optional[str] = None
    would_book_again: Optional[bool] = None
    provider_response: Optional[str] = None
    is_visible: bool = False    # Double-blind: hidden until both parties submit
    created_at: Optional[datetime] = None


@dataclass
class ProviderRating:
    provider_id: str
    composite_rating: Optional[float]   # None if < 5 reviews
    quality_avg: float
    timeliness_avg: float
    communication_avg: float
    total_reviews: int
    would_book_again_pct: float
    rating_trend: str                    # improving, stable, declining
    tier_eligible: str                   # Which tier the provider qualifies for


# Composite rating weights (see DEC-005 in Decision Log)
RATING_WEIGHTS = {
    "quality": 0.50,
    "timeliness": 0.30,
    "communication": 0.20,
}

# Recency weighting: reviews from last 90 days count 2x
RECENCY_WINDOW_DAYS = 90
RECENCY_MULTIPLIER = 2.0

# Minimum reviews before composite rating is displayed publicly
MIN_REVIEWS_FOR_PUBLIC_RATING = 5

# Double-blind auto-reveal window (days)
DOUBLE_BLIND_WINDOW_DAYS = 7

# Review edit window (hours)
EDIT_WINDOW_HOURS = 48

# Tier thresholds
TIER_REQUIREMENTS = {
    "elite": {
        "min_completed_jobs": 50,
        "min_composite_rating": 4.8,
        "max_complaint_rate": 0.02,
    },
    "preferred": {
        "min_completed_jobs": 10,
        "min_composite_rating": 4.5,
        "max_complaint_rate": 0.05,
    },
    "standard": {
        "min_completed_jobs": 0,
        "min_composite_rating": 0,
        "max_complaint_rate": 1.0,
    },
}

# Tier demotion probation period (days)
TIER_PROBATION_DAYS = 30

# Anomaly detection thresholds
ANOMALY_LOW_RATING_THRESHOLD = 3      # Flag reviews below this
ANOMALY_CLUSTER_COUNT = 3             # Flag if N+ low reviews in one week
ANOMALY_NEW_ACCOUNT_DAYS = 14         # Flag reviews from accounts < 14 days old


class ReviewSystem:
    """
    Manages the review lifecycle with weighted composite ratings,
    double-blind submission, tier evaluation, and anti-gaming protections.

    Key design principles:
    - Quality matters most (50% weight) because the work outcome is why
      the customer hired a provider
    - Double-blind prevents retaliation ratings (see DEC-009)
    - Recency weighting ensures current performance matters more than
      historical ratings
    - Minimum 5 reviews before public display prevents small-sample gaming
    """

    def __init__(self, db_connection=None):
        self.db = db_connection

    def submit_review(
        self,
        request_id: str,
        customer_id: str,
        provider_id: str,
        quality: int,
        timeliness: int,
        communication: int,
        comment: Optional[str] = None,
        would_book_again: Optional[bool] = None,
    ) -> Review:
        """
        Submit a customer review for a completed job.

        Validates scores, calculates composite, and determines visibility
        based on double-blind rules.

        The review is NOT immediately visible. It becomes visible when:
        1. Both customer AND provider have submitted reviews, OR
        2. The 7-day double-blind window expires
        """
        # Validate scores
        for score, name in [(quality, "quality"), (timeliness, "timeliness"), (communication, "communication")]:
            if not 1 <= score <= 5:
                raise ValueError(f"{name} score must be between 1 and 5, got {score}")

        composite = self._calculate_composite(quality, timeliness, communication)

        # Check if provider has already submitted their side
        provider_review_exists = self._check_provider_review_exists(request_id, provider_id)

        review = Review(
            id="",  # Generated by database
            request_id=request_id,
            customer_id=customer_id,
            provider_id=provider_id,
            quality_score=quality,
            timeliness_score=timeliness,
            communication_score=communication,
            composite_score=composite,
            comment=comment,
            would_book_again=would_book_again,
            is_visible=provider_review_exists,  # Visible only if both sides submitted
            created_at=datetime.utcnow(),
        )

        # If now visible, recalculate provider's aggregate rating
        if review.is_visible:
            self._recalculate_provider_rating(provider_id)

        # Check for anomalies
        self._check_anomalies(review)

        return review

    def _calculate_composite(self, quality: int, timeliness: int, communication: int) -> float:
        """
        Calculate weighted composite score.

        Formula: (0.50 × quality) + (0.30 × timeliness) + (0.20 × communication)

        Example:
        - Quality=5, Timeliness=3, Communication=4 → 0.50(5) + 0.30(3) + 0.20(4) = 4.2
        - Quality=3, Timeliness=5, Communication=5 → 0.50(3) + 0.30(5) + 0.20(5) = 4.0
        """
        composite = (
            RATING_WEIGHTS["quality"] * quality
            + RATING_WEIGHTS["timeliness"] * timeliness
            + RATING_WEIGHTS["communication"] * communication
        )
        return round(composite, 2)

    def calculate_provider_rating(self, provider_id: str) -> ProviderRating:
        """
        Calculate a provider's aggregate rating across all visible reviews.

        Uses recency weighting: reviews from last 90 days count 2x.
        This ensures recent performance matters more than historical ratings.

        Rating is only displayed publicly after 5+ reviews.

        In production:
        SELECT
            quality_score, timeliness_score, communication_score,
            composite_score, would_book_again, created_at
        FROM reviews
        WHERE provider_id = $1
            AND is_visible = true
        ORDER BY created_at DESC;
        """
        # Reference: simulate with sample data
        reviews = self._get_visible_reviews(provider_id)

        if not reviews:
            return ProviderRating(
                provider_id=provider_id,
                composite_rating=None,
                quality_avg=0,
                timeliness_avg=0,
                communication_avg=0,
                total_reviews=0,
                would_book_again_pct=0,
                rating_trend="stable",
                tier_eligible="standard",
            )

        # Recency-weighted averages
        cutoff = datetime.utcnow() - timedelta(days=RECENCY_WINDOW_DAYS)
        total_weight = 0
        weighted_quality = 0
        weighted_timeliness = 0
        weighted_communication = 0
        weighted_composite = 0
        book_again_count = 0
        book_again_total = 0

        for review in reviews:
            weight = RECENCY_MULTIPLIER if review.created_at and review.created_at >= cutoff else 1.0
            total_weight += weight

            weighted_quality += review.quality_score * weight
            weighted_timeliness += review.timeliness_score * weight
            weighted_communication += review.communication_score * weight
            weighted_composite += review.composite_score * weight

            if review.would_book_again is not None:
                book_again_total += weight
                if review.would_book_again:
                    book_again_count += weight

        quality_avg = round(weighted_quality / total_weight, 2)
        timeliness_avg = round(weighted_timeliness / total_weight, 2)
        communication_avg = round(weighted_communication / total_weight, 2)
        composite_avg = round(weighted_composite / total_weight, 2)

        book_again_pct = round(book_again_count / book_again_total, 2) if book_again_total > 0 else 0

        # Only show composite publicly if enough reviews
        public_rating = composite_avg if len(reviews) >= MIN_REVIEWS_FOR_PUBLIC_RATING else None

        # Calculate trend (compare last 30 days to 30-60 days ago)
        trend = self._calculate_trend(reviews)

        # Determine tier eligibility
        tier = self._evaluate_tier_eligibility(
            provider_id, composite_avg, len(reviews)
        )

        return ProviderRating(
            provider_id=provider_id,
            composite_rating=public_rating,
            quality_avg=quality_avg,
            timeliness_avg=timeliness_avg,
            communication_avg=communication_avg,
            total_reviews=len(reviews),
            would_book_again_pct=book_again_pct,
            rating_trend=trend,
            tier_eligible=tier,
        )

    def _calculate_trend(self, reviews: list[Review]) -> str:
        """
        Compare recent rating (last 30 days) to prior period (30-60 days ago).

        - Improving: recent > prior by 0.2+
        - Declining: recent < prior by 0.2+
        - Stable: within 0.2
        """
        now = datetime.utcnow()
        recent_cutoff = now - timedelta(days=30)
        prior_cutoff = now - timedelta(days=60)

        recent = [r for r in reviews if r.created_at and r.created_at >= recent_cutoff]
        prior = [r for r in reviews if r.created_at and prior_cutoff <= r.created_at < recent_cutoff]

        if not recent or not prior:
            return "stable"

        recent_avg = sum(r.composite_score for r in recent) / len(recent)
        prior_avg = sum(r.composite_score for r in prior) / len(prior)

        diff = recent_avg - prior_avg
        if diff >= 0.2:
            return "improving"
        elif diff <= -0.2:
            return "declining"
        return "stable"

    def _evaluate_tier_eligibility(
        self,
        provider_id: str,
        composite_rating: float,
        total_reviews: int,
    ) -> str:
        """
        Determine which tier a provider qualifies for based on current metrics.

        Evaluation order: Elite → Preferred → Standard (highest qualifying tier wins).

        In production, also pulls:
        - total_completed_jobs from providers table
        - complaint_rate from providers table (disputes / completed jobs)

        Tier changes:
        - Promotion: immediate when requirements met
        - Demotion: 30-day probation period before downgrade
        """
        # In production: fetch from providers table
        completed_jobs = self._get_completed_jobs_count(provider_id)
        complaint_rate = self._get_complaint_rate(provider_id)

        for tier_name in ["elite", "preferred", "standard"]:
            reqs = TIER_REQUIREMENTS[tier_name]
            if (
                completed_jobs >= reqs["min_completed_jobs"]
                and composite_rating >= reqs["min_composite_rating"]
                and complaint_rate <= reqs["max_complaint_rate"]
            ):
                return tier_name

        return "standard"

    def evaluate_tier_change(self, provider_id: str, current_tier: str) -> dict:
        """
        Monthly tier evaluation for a provider.

        Returns promotion, demotion, or no change with reasoning.
        Demotion triggers a 30-day probation before actual downgrade.

        In production: run monthly via cron job for all active providers.
        """
        rating = self.calculate_provider_rating(provider_id)
        eligible_tier = rating.tier_eligible

        if eligible_tier == current_tier:
            return {
                "provider_id": provider_id,
                "current_tier": current_tier,
                "action": "none",
                "reason": "Meets current tier requirements",
            }

        tier_order = {"standard": 0, "preferred": 1, "elite": 2}

        if tier_order.get(eligible_tier, 0) > tier_order.get(current_tier, 0):
            return {
                "provider_id": provider_id,
                "current_tier": current_tier,
                "new_tier": eligible_tier,
                "action": "promote",
                "reason": f"Meets {eligible_tier} tier requirements. Rating: {rating.composite_rating}, Reviews: {rating.total_reviews}",
                "effective": "immediate",
            }

        # Demotion: trigger probation first
        return {
            "provider_id": provider_id,
            "current_tier": current_tier,
            "new_tier": eligible_tier,
            "action": "probation",
            "reason": f"Below {current_tier} tier requirements. Rating: {rating.composite_rating}. 30-day probation starts now.",
            "probation_ends": (datetime.utcnow() + timedelta(days=TIER_PROBATION_DAYS)).isoformat(),
            "recovery_needed": self._get_recovery_targets(current_tier, rating),
        }

    def _get_recovery_targets(self, current_tier: str, rating: ProviderRating) -> dict:
        """What the provider needs to do to maintain their current tier during probation."""
        reqs = TIER_REQUIREMENTS[current_tier]
        targets = {}

        if rating.composite_rating and rating.composite_rating < reqs["min_composite_rating"]:
            targets["composite_rating"] = {
                "current": rating.composite_rating,
                "required": reqs["min_composite_rating"],
                "tip": "Focus on the dimension where you score lowest. Small improvements in your weakest area have the biggest impact on your composite.",
            }

        return targets

    def check_double_blind_reveals(self) -> list[str]:
        """
        Daily job: reveal reviews where the 7-day double-blind window has expired.

        If one party submitted a review but the other didn't within 7 days,
        the submitted review becomes visible.

        In production:
        UPDATE reviews SET is_visible = true
        WHERE is_visible = false
            AND created_at < NOW() - INTERVAL '7 days';
        """
        return []

    def _check_anomalies(self, review: Review) -> list[dict]:
        """
        Anti-gaming detection. Flag suspicious patterns for operator review.

        Checks:
        1. Cluster detection: 3+ low ratings (< 3) for a provider in one week
        2. New account reviews: reviewer account < 14 days old
        3. Rating pattern: all 5-stars from accounts created in same week (fake boost)
        4. Self-review: customer and provider share email domain or IP
        """
        anomalies = []

        # Check 1: Low rating cluster
        if review.composite_score < ANOMALY_LOW_RATING_THRESHOLD:
            recent_low_count = self._count_recent_low_reviews(
                review.provider_id, days=7
            )
            if recent_low_count >= ANOMALY_CLUSTER_COUNT:
                anomalies.append({
                    "type": "low_rating_cluster",
                    "provider_id": review.provider_id,
                    "count": recent_low_count,
                    "severity": "high",
                    "action": "operator_investigation",
                })

        # Check 2: New account
        account_age_days = self._get_customer_account_age(review.customer_id)
        if account_age_days is not None and account_age_days < ANOMALY_NEW_ACCOUNT_DAYS:
            anomalies.append({
                "type": "new_account_review",
                "customer_id": review.customer_id,
                "account_age_days": account_age_days,
                "severity": "medium",
                "action": "flag_for_review",
            })

        return anomalies

    # Database helper stubs (implemented against actual DB in production)
    def _check_provider_review_exists(self, request_id: str, provider_id: str) -> bool:
        return False

    def _recalculate_provider_rating(self, provider_id: str) -> None:
        pass

    def _get_visible_reviews(self, provider_id: str) -> list[Review]:
        return []

    def _get_completed_jobs_count(self, provider_id: str) -> int:
        return 0

    def _get_complaint_rate(self, provider_id: str) -> float:
        return 0.0

    def _count_recent_low_reviews(self, provider_id: str, days: int) -> int:
        return 0

    def _get_customer_account_age(self, customer_id: str) -> Optional[int]:
        return None
